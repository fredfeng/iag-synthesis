traversal layout {
    case Viewport {
        ??;
        recur root;
    }
    case Block {
        ??;
        iterate children { ??; recur children; ??; }
        ??;
    }
    case Inline {
        ??;
    }
    case Floated {
        ??;
        iterate children { ??; recur children; ??; }
        ??;
    }
}

traversal pre {
    case Viewport {
        ??;
        recur root;
    }
    case Block {
        ??;
        iterate children { ??; recur children; ??; }
    }
    case Floated {
        ??;
        iterate children { ??; recur children; ??; }
    }
    case Inline {
        ??;
    }
}

traversal post {
    case Viewport {
        recur root;
        ??;
    }
    case Block {
        iterate children { ??; recur children; ??; }
        ??;
    }
    case Floated {
        iterate children { ??; recur children; ??; }
        ??;
    }
    case Inline {
        ??;
    }
}

interface Tree {
    input width : Pixels;
    input height : Pixels;
}

/* The document viewport. */
class Viewport : Tree {
    children {
        root : LayoutNode; // The initial containing block.
    }
    rules {
        root.container.x := 0.0;
        root.container.y := 0.0;
        root.container.width := self.width;
        root.container.height := 0.0; // self.height
        root.float_cursor_in := FloatCursor::empty();
    }
}

interface LayoutNode {
    // Container box
    output container.x : Pixels;
    output container.y : Pixels;
    output container.width : Pixels;
    output container.height : Pixels;

    // Content box (computed)
    output content_box.x : Pixels;
    output content_box.y : Pixels;
    output content_box.width : Pixels;
    output content_box.height : Pixels;

    // Padding box (computed)
    output padding_box.x : Pixels;
    output padding_box.y : Pixels;
    output padding_box.width : Pixels;
    output padding_box.height : Pixels;

    // Border box (computed)
    output border_box.x : Pixels;
    output border_box.y : Pixels;
    output border_box.width : Pixels;
    output border_box.height : Pixels;

    // Margin box (computed)
    output margin_box.x : Pixels;
    output margin_box.y : Pixels;
    output margin_box.width : Pixels;
    output margin_box.height : Pixels;

    // Padding edges (computed)
    output padding.left : Pixels;
    output padding.right : Pixels;
    output padding.top : Pixels;
    output padding.bottom : Pixels;

    // Border edges (computed)
    output border.left : Pixels;
    output border.right : Pixels;
    output border.top : Pixels;
    output border.bottom : Pixels;

    // Margin edges (computed)
    output margin.left : Pixels;
    output margin.right : Pixels;
    output margin.top : Pixels;
    output margin.bottom : Pixels;

    // Difference between intrinsic and container widths
    output underflow : Pixels;

    // Anonymity
    input anonymous : bool;

    // Display and position mode
    input style.display : Display;
    input style.position : Positioned;
    input style.float : Floated;
    input style.clear.left : bool;
    input style.clear.right : bool;

    // Colors
    input style.background_color : Color;
    input style.border_color : Color;

    // Content size (specified)
    input style.width : Automatic<Pixels>;
    input style.height : Automatic<Pixels>;

    // Content edges (specified)
    input style.left : Automatic<Pixels>;
    input style.right : Automatic<Pixels>;
    input style.top : Automatic<Pixels>;
    input style.bottom : Automatic<Pixels>;

    // Margin edges (specified)
    input style.margin.left : Automatic<Pixels>;
    input style.margin.right : Automatic<Pixels>;
    input style.margin.top : Automatic<Pixels>;
    input style.margin.bottom : Automatic<Pixels>;

    // Padding edges (specified)
    input style.padding.left : Pixels;
    input style.padding.right : Pixels;
    input style.padding.top : Pixels;
    input style.padding.bottom : Pixels;

    // Border edges (specified)
    input style.border.left : Pixels;
    input style.border.right : Pixels;
    input style.border.top : Pixels;
    input style.border.bottom : Pixels;

    // Margin collapse
    //output margin_above.positive : Pixels;
    //output margin_above.negative : Pixels;
    output margin_above.collapse : bool;
    //output margin_below.positive : Pixels;
    //output margin_below.negative : Pixels;
    output margin_below.collapse : bool;

    // Float positioning
    input style.float : Float;
    output float_cursor_in : FloatCursor;
    output float_cursor_out : FloatCursor;
    output float_clearance : Pixels;
    output block_size : Pixels;
    input carried_margin : Pixels;
}

class Block : LayoutNode {
    children {
        children : [LayoutNode];
    }
    rules {
        self.border.top := self.style.border.top;
        self.border.bottom := self.style.border.bottom;

        self.padding.top := self.style.padding.top;
        self.padding.bottom := self.style.padding.bottom;

        self.margin_above.collapse :=
            self.padding.top == 0.0 && self.border.top == 0.0;
        self.margin_below.collapse :=
            self.padding.bottom == 0.0 && self.border.bottom == 0.0 &&
            is_auto(self.style.height);

        self.margin.top := max(value(self.style.margin.top) - self.carried_margin, 0.0);
        self.margin.bottom := value(self.style.margin.bottom);

        self.content_box.x :=
            self.container.x +
            self.padding.left + self.border.left + self.margin.left;

        // Position the box below all the previous boxes in the container.
        self.content_box.y :=
            max(
                self.container.y + self.container.height +
                self.padding.top + self.border.top + self.margin.top,
                max(
                    if self.style.clear.left then left_clearance(self.float_cursor_in) else 0.0,
                    if self.style.clear.right then right_clearance(self.float_cursor_in) else 0.0
                )
            );

        self.underflow :=
            self.container.width -
            (value(self.style.margin.left) + value(self.style.margin.right) +
             self.style.border.left + self.style.border.right +
             self.style.padding.left + self.style.padding.right +
             value(self.style.width));

        self.padding.left := self.style.padding.left;
        self.padding.right := self.style.padding.right;

        self.border.left := self.style.border.left;
        self.border.right := self.style.border.right;

        self.content_box.width :=
            if is_auto(self.style.width) then
                max(self.underflow, 0.0)
            else
                value(self.style.width);

        self.margin.left :=
            if is_auto(self.style.margin.left) then
                if is_auto(self.style.width) || self.underflow < 0.0 then
                    0.0
                else if is_auto(self.style.margin.right) then
                    self.underflow / 2.0
                else
                    self.underflow
            else
                value(self.style.margin.left);

        self.margin.right :=
            if is_auto(self.style.width) && self.underflow < 0.0 then
                value(self.style.margin.right) + self.underflow
            else if is_auto(self.style.margin.right) then
                if is_auto(self.style.width) then
                    0.0
                else if is_auto(self.style.margin.left) then
                    self.underflow / 2.0
                else
                    self.underflow
            else if !is_auto(self.style.margin.left) || !is_auto(self.style.width) then
                value(self.style.margin.right) + self.underflow
            else
                value(self.style.margin.right);

        children[i].container.x := self.content_box.x;
        children[i].container.y := self.content_box.y;

        children[i].container.width := self.content_box.width;
        self.block_size := self.margin_box.height;

        children[i].container.height := scanl 0.0 .. children[@].container.height + children[i].block_size;

        self.content_box.height :=
            if is_auto(self.style.height) then
                children[$].container.height
            else
                value(self.style.height);

        self.padding_box.x := self.content_box.x - self.padding.left;
        self.padding_box.y := self.content_box.y - self.padding.top;
        self.padding_box.width := self.content_box.width + self.padding.left + self.padding.right;
        self.padding_box.height := self.content_box.height + self.padding.top + self.padding.bottom;

        self.border_box.x := self.padding_box.x - self.border.left;
        self.border_box.y := self.padding_box.y - self.border.top;
        self.border_box.width := self.padding_box.width + self.border.left + self.border.right;
        self.border_box.height := self.padding_box.height + self.border.top + self.border.bottom;

        self.margin_box.x := self.border_box.x - self.margin.left;
        self.margin_box.y := self.border_box.y - self.margin.top;
        self.margin_box.width := self.border_box.width + self.margin.left + self.margin.right;
        self.margin_box.height := self.border_box.height + self.margin.top + self.margin.bottom;

        children[i].float_cursor_in := FloatCursor::empty();
        self.float_cursor_out := clone(self.float_cursor_in);
    }
}

/* display: inline */
class Inline : LayoutNode {
    rules {
        self.underflow :=
            self.container.width -
            (value(self.style.margin.left) + value(self.style.margin.right) +
             self.style.border.left + self.style.border.right +
             self.style.padding.left + self.style.padding.right +
             value(self.style.width));

        self.padding.left := self.style.padding.left;
        self.padding.right := self.style.padding.right;

        self.border.left := self.style.border.left;
        self.border.right := self.style.border.right;

        self.content_box.width :=
            if is_auto(self.style.width) then
                max(self.underflow, 0.0)
            else
                value(self.style.width);

        self.margin.left :=
            if is_auto(self.style.margin.left) then
                if is_auto(self.style.width) || self.underflow < 0.0 then
                    0.0
                else if is_auto(self.style.margin.right) then
                    self.underflow / 2.0
                else
                    self.underflow
            else
                value(self.style.margin.left);

        self.margin.right :=
            if is_auto(self.style.width) && self.underflow < 0.0 then
                value(self.style.margin.right) + self.underflow
            else if is_auto(self.style.margin.right) then
                if is_auto(self.style.width) then
                    0.0
                else if is_auto(self.style.margin.left) then
                    self.underflow / 2.0
                else
                    self.underflow
            else if !is_auto(self.style.margin.left) || !is_auto(self.style.width) then
                value(self.style.margin.right) + self.underflow
            else
                value(self.style.margin.right);

        self.margin.top := value(self.style.margin.top); // auto ==> 0
        self.margin.bottom := value(self.style.margin.bottom); // auto ==> 0

        self.border.top := self.style.border.top;
        self.border.bottom := self.style.border.bottom;

        self.padding.top := self.style.padding.top;
        self.padding.bottom := self.style.padding.bottom;

        self.content_box.x :=
            self.container.x +
            self.margin.left + self.border.left + self.padding.left;

        self.content_box.y :=
            self.container.y + self.container.height +
            self.margin.top + self.border.top + self.padding.top;

        self.content_box.height := value(self.style.height);

        self.padding_box.x := self.content_box.x - self.padding.left;
        self.padding_box.y := self.content_box.y - self.padding.top;
        self.padding_box.width := self.content_box.width + self.padding.left + self.padding.right;
        self.padding_box.height := self.content_box.height + self.padding.top + self.padding.bottom;

        self.border_box.x := self.padding_box.x - self.border.left;
        self.border_box.y := self.padding_box.y - self.border.top;
        self.border_box.width := self.padding_box.width + self.border.left + self.border.right;
        self.border_box.height := self.padding_box.height + self.border.top + self.border.bottom;

        self.margin_box.x := self.border_box.x - self.margin.left;
        self.margin_box.y := self.border_box.y - self.margin.top;
        self.margin_box.width := self.border_box.width + self.margin.left + self.margin.right;
        self.margin_box.height := self.border_box.height + self.margin.top + self.margin.bottom;

        self.float_cursor_out := clone(self.float_cursor_in);
        // not sure if it's correct.
        self.block_size := self.content_box.height;
    }
}

class Floated : LayoutNode {
    children {
        children : [LayoutNode];
    }
    rules {
        self.float_cursor_out := add_left(self.float_cursor_in, self.content_box.x, self.content_box.y, self.content_box.width, self.content_box.height);

        ///copy paste
        self.underflow :=
            self.container.width -
            (value(self.style.margin.left) + value(self.style.margin.right) +
             self.style.border.left + self.style.border.right +
             self.style.padding.left + self.style.padding.right +
             value(self.style.width));

        self.padding.left := 0.0;
        self.padding.right := 0.0;

        self.border.left := self.style.border.left;
        self.border.right := self.style.border.right;

        self.content_box.width :=
            if is_auto(self.style.width) then
                max(self.underflow, 0.0)
            else
                value(self.style.width);

        self.margin.left := 0.0;

        self.margin.right := 0.0;

        self.margin.top := 0.0; // auto ==> 0
        self.margin.bottom := 0.0; // auto ==> 0

        self.border.top := self.style.border.top;
        self.border.bottom := self.style.border.bottom;

        self.padding.top := 0.0;
        self.padding.bottom := 0.0;

        self.content_box.x :=
            self.container.x +
            self.margin.left + self.border.left + self.padding.left;

        self.content_box.y :=
            self.container.y + self.container.height +
            self.margin.top + self.border.top + self.padding.top;

        children[i].container.x := self.content_box.x;
        children[i].container.y := self.content_box.y;

        children[i].container.width := self.content_box.width;

        children[i].container.height := scanl 0.0 .. children[@].container.height + children[i].margin_box.height;

        self.content_box.height :=
            if is_auto(self.style.height) then
                children[$].container.height
            else
                value(self.style.height);

        self.padding_box.x := self.content_box.x - self.padding.left;
        self.padding_box.y := self.content_box.y - self.padding.top;
        self.padding_box.width := self.content_box.width + self.padding.left + self.padding.right;
        self.padding_box.height := self.content_box.height + self.padding.top + self.padding.bottom;

        self.border_box.x := self.padding_box.x - self.border.left;
        self.border_box.y := self.padding_box.y - self.border.top;
        self.border_box.width := self.padding_box.width + self.border.left + self.border.right;
        self.border_box.height := self.padding_box.height + self.border.top + self.border.bottom;

        self.margin_box.x := self.border_box.x - self.margin.left;
        self.margin_box.y := self.border_box.y - self.margin.top;
        self.margin_box.width := self.border_box.width + self.margin.left + self.margin.right;
        self.margin_box.height := self.border_box.height + self.margin.top + self.margin.bottom;

        children[i].float_cursor_in := FloatCursor::empty();

        self.block_size := 0.0;
    }
}
